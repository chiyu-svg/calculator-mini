1. 0.1 + 0.2 !== 0.3 计算机无法精确表示小数
输出结果展示图片
备注：这个问题不局限于单个编程语言
造成原因：计算机使用二进制的方式进行存储，在存储值的时候，会把人类常用的十进制转换成二进制，小数也是如此。
在计算机当中小数是通过三个部分进行表示的，分别包括符号位、指数位、尾数位。 这里我们重点放在尾数位上，举个例子：
0.1415926。在转换的过程中会把0.1415926 小数部分不断乘2 取整，这个过程会继续直到我们得到足够的二进制位数或小数部分变为0。
这里就会出现一个问题，不管怎么乘怎么取小数部分都不会变成0，也就是无限循环小数，但计算机存储能表示的位数长度又是有限的，所以
会截取掉无法表示的部分，这也就导致了精度的损失，也是为什么小数有的时候能精确表示有的时候不能精确表示的原因。
开发中一般如何处理这种问题：
适业务需求而定, 一般通过指定保留小数位的个数，四舍五入来处理
代码：
JS
  let num = 3.1415926;
  num.toFixed(3); 
python
  num = round(3.1415926, 3) 
  # 使用 round 时候要注意, round 使用规则为 “银行家舍入” 即：当一个数字精确地位于两个可用的数值中间时（即，数字的尾数是5），会被舍入到最近的偶数, 这样的规则可以减少统计数据误差。从中可以看出 python 的确在数据分析上更有天赋
  from decimal import Decimal, ROUND_HALF_UP
  num = Decimal("3.1415926").quantize(Decimal("0.001"), rounding=ROUND_HALF_UP)
  print(num)
  # Decimal 可以指定精度来更精确的运算
2. 类型转换成布尔值
3. 字符串拼接
4. 按索引取字符串的
5. 字符串反转
6. 数据类型转换
7. 判断值是否相等
8. 连续做逻辑运算
9. 成员和身份判断
10. 效率改善条件语句

水文 - 为什么计算机使用补码能计算正确的结果
想象你有一个很奇特的钟表，这个钟表不是标准的1到12的数字，而是只能从0数到255（因为我们在这个例子中使用8位二进制）。现在，如果这个钟表指向了“5”，你反方向倒退5步，那么它就会回到“0”。但如果你想从“5”倒退“8”步，怎么办？在这个钟表上，你实际上会倒退到“250”。这个操作的结果就好似数了一大圈最终又回来了。

在计算机的二进制世界里，情况也是类似的。我们用一个固定的位数来表示所有的数，比如8位。如果我们向前超出了这个范围（比如“256”或者更高），计算机会“忽略”超出的部分，就像钟表转了一圈回到起点一样。所以在8位计算机中，“256”会回到“0”。

补码就像是找到这个钟表上的“负数”。如果你想计算“5 - 8”，你可以用“5 + （256 - 8）”来代替。因为“256 - 8”等于“248”，所以我们想在钟表上从“5”开始往后数“248”步，结果会得到“253”（在二进制中是“11111101”）。但实际上，这个钟表上的数字“253”就相当于我们正常情况下的“-3”！

用补码表示，我们就不直接说“-8”，而是说“256 - 8”，用一个“可以正向数”的数来表示一个负数。而且，这极大地简化了计算机内部做减法的工作，因为计算机只需要做加法：它简单地把5和“256 - 8”相加，最后得出的结果就是“5 - 8”。