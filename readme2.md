1. 0.1 + 0.2 !== 0.3 计算机无法精确表示小数
输出结果展示图片
备注：这个问题不局限于单个编程语言
造成原因：计算机使用二进制的方式进行存储，在存储值的时候，会把人类常用的十进制转换成二进制，小数也是如此。
在计算机当中小数是通过三个部分进行表示的，分别包括符号位、指数位、尾数位。 这里我们重点放在尾数位上，举个例子：
0.1415926。在转换的过程中会把0.1415926 小数部分不断乘2 取整，这个过程会继续直到我们得到足够的二进制位数或小数部分变为0。
这里就会出现一个问题，不管怎么乘怎么取小数部分都不会变成0，也就是无限循环小数，但计算机存储能表示的位数长度又是有限的，所以
会截取掉无法表示的部分，这也就导致了精度的损失，也是为什么小数有的时候能精确表示有的时候不能精确表示的原因。
开发中一般如何处理这种问题：
适业务需求而定, 一般通过指定保留小数位的个数，四舍五入来处理
代码：
JS
  let num = 3.1415926;
  num.toFixed(3); 
python
  num = round(3.1415926, 3) 
  # 使用 round 时候要注意, round 使用规则为 “银行家舍入” 即：当一个数字精确地位于两个可用的数值中间时（即，数字的尾数是5），会被舍入到最近的偶数, 这样的规则可以减少统计数据误差。从中可以看出 python 的确在数据分析上更有天赋
  from decimal import Decimal, ROUND_HALF_UP
  num = Decimal("3.1415926").quantize(Decimal("0.001"), rounding=ROUND_HALF_UP)
  print(num)
  # Decimal 可以指定精度来更精确的运算
2. 布尔类型的隐式转换以及在条件语句的应用
每个编程语言都会有布尔类型，用来表示 true/false 从而做条件语句的执行逻辑判断。
举例:
    let num = 10;
    if(num > 5) {
        console.log("num 大于 5")
    }
就拿 if 条件语句来说，当if(true) 时才会执行语句内的内容。很明显括号中是布尔类型。所以我们有理由在使用 if 之类语句的时候
要使用布尔类型。
通常逻辑判断表达式会返回一个布尔类型，比如 a > b, a < b, a !== b, !a 当然还有直接赋值 a = true/false
这是重点: 有些编程语言在使用类似条件语句判断时会隐式的转换成布尔类型。转换规则是把表示空/不存在的数据转换成 false 其它都转换成 true
JavaScript
let n = 1;
if(n) {
    console.log('执行了')
}
在执行的时候if(n) 的 n 被隐式转换成了布尔类型
注意：当 a = "0", a = [], a = {} 会隐式转换成 true 不是 false

python3
list = []
if list:
    print("true")
else:
    print("false")
python 中 “0”, "0.0", [], {} 之类都会被转成false

Rust
fn main() {
    let option_value: Option<i32> = None;
    if let Some(value) = option_value {
        println!("{}", value);
    } else {
        println!("none");
    }
}
可见 Rust 中并没隐式转换，甚至都没有空的概念，而是考虑一个值可能存在空值的情况，并进行做处理。 不愧为语言层次上的安全语言
5. 如何优雅的字符串反转
如何反转一个字符串或者一个数组，在编程领域有着非常大的作用，仔细想想好像又没有什么作用，那为什么要记录下来呢？是因为
在学习python的时候被切片的好用给震惊了那么一下下，特此记录一下表达自己对编程的那么一丢丢热爱
JavaScript
let slogan = "hello world";
let re_slogan = slogan.split('').reverse().join('');
// 先分割成数组之后在反转拼接，js 够优雅

python3
方式1
slogan = "hello world"
re_slogan = ''.join(reversed(slogan))
// 与 js 的一样的方式，优雅

方式2
slogan = "hello world"
re_slogan = slogan[::-1]
// 这是让我感觉到惊讶的地方，优雅之上

Rust
fn main() {
    let slogan = "hello world";
    let re_slogn: String = slogan.chars().rev().collect();
    println!("{}", re_slogn);
}
// 注意Rust的字符串组成不是字符而是字节的，所以第一步要切割成字符迭代器，在进行反转。 

总结：优雅程度上来讲，这波站 python


8. 编程小习惯-连续做逻辑运算
在写代码的时候，逻辑判断是经常要用到的，其中有一类场景特别符合人类的语言习惯，比如：为分数（score）评级，当
score 大于等于 80 分小于 90 分的时候评为 B, 这个时候就经常会自然而然的写出 90 > score >= 80 这样的表达式
如果我们是在写 python 代码，那会像呼吸一样简单
score = 85
90 > score >= 80 # 输出 True， ok 没有问题

如果我们是在写 JavaScript 代码, 那似乎一切都变的不再那么简单
let score = 85;
90 > score >= 80; 
// 输出为 false, 其实一点都不惊喜反正会输出一个布尔值，不是 true 就是 false 呗
不过这里的执行逻辑过程是值的研究一下的。
JavaScript 解析器在解析 90 > score >= 80 这行代码的时候，会先执行 90 > score 这时返回一个值 true, 然后拿这个
true 在和 80 做比较就变成了 true >= 80， 因为两边的数据类型不相同，故会发生隐式转换，怎么转？偏向数字类型转，也就变成了 1 >= 80. 因此结果返回 false

如果我们时在写 Rust 代码， sorry, 不能执行
fn main() {
    let score: u8 = 80;
    println!("{}", 90 > score >= 80);
}
rustc 在编译这段代码的时候，会先执行 90 > score 这时得到一个布尔值，布尔值 >= u8 类型，类型不一致，报错。


    


9. 成员和身份判断
10. 效率改善条件语句



水文 - 为什么计算机使用补码能计算正确的结果
想象你有一个很奇特的钟表，这个钟表不是标准的1到12的数字，而是只能从0数到255（因为我们在这个例子中使用8位二进制）。现在，如果这个钟表指向了“5”，你反方向倒退5步，那么它就会回到“0”。但如果你想从“5”倒退“8”步，怎么办？在这个钟表上，你实际上会倒退到“250”。这个操作的结果就好似数了一大圈最终又回来了。

在计算机的二进制世界里，情况也是类似的。我们用一个固定的位数来表示所有的数，比如8位。如果我们向前超出了这个范围（比如“256”或者更高），计算机会“忽略”超出的部分，就像钟表转了一圈回到起点一样。所以在8位计算机中，“256”会回到“0”。

补码就像是找到这个钟表上的“负数”。如果你想计算“5 - 8”，你可以用“5 + （256 - 8）”来代替。因为“256 - 8”等于“248”，所以我们想在钟表上从“5”开始往后数“248”步，结果会得到“253”（在二进制中是“11111101”）。但实际上，这个钟表上的数字“253”就相当于我们正常情况下的“-3”！

用补码表示，我们就不直接说“-8”，而是说“256 - 8”，用一个“可以正向数”的数来表示一个负数。而且，这极大地简化了计算机内部做减法的工作，因为计算机只需要做加法：它简单地把5和“256 - 8”相加，最后得出的结果就是“5 - 8”。